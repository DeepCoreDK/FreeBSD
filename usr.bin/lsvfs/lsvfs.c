/*
 * lsvfs - list loaded VFSes
 * Garrett A. Wollman, September 1994
 * This file is in the public domain.
 *
 */

#include <sys/capsicum.h>
#include <sys/param.h>
#include <sys/mount.h>
#include <sys/sysctl.h>

#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <libcasper.h>
#include <casper/cap_sysctl.h>

#define FMT	"%-32.32s 0x%08x %5d  %s\n"
#define HDRFMT	"%-32.32s %10s %5.5s  %s\n"
#define DASHES	"-------------------------------- "	\
		"---------- -----  ---------------\n"

static struct flaglist {
	int		flag;
	const char	str[32]; /* must be longer than the longest one. */
} fl[] = {
	{ .flag = VFCF_STATIC, .str = "static", },
	{ .flag = VFCF_NETWORK, .str = "network", },
	{ .flag = VFCF_READONLY, .str = "read-only", },
	{ .flag = VFCF_SYNTHETIC, .str = "synthetic", },
	{ .flag = VFCF_LOOPBACK, .str = "loopback", },
	{ .flag = VFCF_UNICODE, .str = "unicode", },
	{ .flag = VFCF_JAIL, .str = "jail", },
	{ .flag = VFCF_DELEGADMIN, .str = "delegated-administration", },
};

static const char *fmt_flags(int);

int
main(int argc, char **argv)
{
	struct xvfsconf vfc, *xvfsp;
	size_t buflen;
	int cnt, rv = 0;
	cap_channel_t *capcas, *capsysctl;
	cap_sysctl_limit_t *limit;

	argc--, argv++;

	if ((capcas = cap_init()) == NULL)
		err(EXIT_FAILURE, "unable to contact Casper");
	if ((capsysctl = cap_service_open(capcas, "system.sysctl")) == NULL)
		err(EXIT_FAILURE, "unable to open system.sysctl servic");
	cap_close(capcas);

	limit = cap_sysctl_limit_init(capsysctl);
	cap_sysctl_limit_name(limit, "vfs.conflist", CAP_SYSCTL_READ);
	if (cap_sysctl_limit(limit) < 0)
		err(EXIT_FAILURE, "unable to set limits");

	if (caph_enter_casper() != 0)
		err(EXIT_FAILURE, "failed to enter capability mode");

	printf(HDRFMT, "Filesystem", "Num", "Refs", "Flags");
	fputs(DASHES, stdout);

	if (argc > 0) {
		for (; argc > 0; argc--, argv++) {
			if (getvfsbyname(*argv, &vfc) == 0) {
				printf(FMT, vfc.vfc_name, vfc.vfc_typenum,
				    vfc.vfc_refcount, fmt_flags(vfc.vfc_flags));
			} else {
				warnx("VFS %s unknown or not loaded", *argv);
				rv++;
			}
		}
	} else {
		if (cap_sysctlbyname(capsysctl, "vfs.conflist", NULL, &buflen, NULL, 0) < 0)
			err(EXIT_FAILURE, "sysctl(vfs.conflist)");
		if ((xvfsp = malloc(buflen)) == NULL)
			errx(EXIT_FAILURE, "malloc failed");
		if (cap_sysctlbyname(capsysctl, "vfs.conflist", xvfsp, &buflen, NULL, 0) < 0)
			err(EXIT_FAILURE, "sysctl(vfs.conflist)");
		cnt = buflen / sizeof(struct xvfsconf);

		for (int i = 0; i < cnt; i++) {
			printf(FMT, xvfsp[i].vfc_name, xvfsp[i].vfc_typenum,
			    xvfsp[i].vfc_refcount,
			    fmt_flags(xvfsp[i].vfc_flags));
		}
		free(xvfsp);
	}

	return (rv);
}

static const char *
fmt_flags(int flags)
{
	static char buf[sizeof(struct flaglist) * sizeof(fl)];

	buf[0] = '\0';
	for (int i = 0; i < (int)nitems(fl); i++) {
		if ((flags & fl[i].flag) != 0) {
			strlcat(buf, fl[i].str, sizeof(buf));
			strlcat(buf, ", ", sizeof(buf));
		}
	}

	/* Zap the trailing comma + space. */
	if (buf[0] != '\0')
		buf[strlen(buf) - 2] = '\0';
	return (buf);
}
